import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Timer;
import java.util.TimerTask;

import javax.imageio.ImageIO;
import javax.swing.JPanel;

/**
 * Title Screen Class For Opening Menus
 * @author Nicholas Lorentzen
 * @version 20190602
 */
public class TitleScreen extends JPanel
{
	
	// General Settings
	/** Maximum Screen Size Height */
	private static final int MAX_SCREEN_SIZE_HEIGHT = 1080;
	/** Maximum Screen Size Width */
	private static final int MAX_SCREEN_SIZE_WIDTH = 1920;
	/** Default Delay for Mouse Input When Navigating Menus */
	private static final int DEFAULT_MOUSE_DELAY = 500;
	
	// Character Select Locations
	/** Y Position of Current Picker Text */
	private static final double CURRENT_PICKER_Y = 109.94;
	/** X Position of Current Picker Text */
	private static final int CURRENT_PICKER_X = 60;
	/** Y Position of Character Preview */
	private static final int CHARACTER_PREVIEW_Y = 17;
	/** X Position of Character Preview */
	private static final int CHARACTER_PREVIEW_X = 721;
	
	// Instructions Button Location
	/** Y2 Location of Instructions Button */
	private static final int INSTRUCTIONSBUTTON_Y_2 = 456;
	/** Y1 Location of Instructions Button */
	private static final int INSTRUCTIONSBUTTON_Y_1 = 406;
	/** X2 Location of Instructions Button */
	private static final int INSTRUCTIONSBUTTON_X_2 = 445;
	/** X1 Location of Instructions Button */
	private static final int INSTRUCTIONSBUTTON_X_1 = 153;
	
	// Exit Button Location
	/** Y2 Location of Exit Button */
	private static final int EXITBUTTON_Y_2 = 537;
	/** Y1 Location of Exit Button */
	private static final int EXITBUTTON_Y_1 = 470;
	/** X2 Location of Exit Button */
	private static final int EXITBUTTON_X_2 = 252;
	/** X1 Location of Exit Button */
	private static final int EXITBUTTON_X_1 = 153;
	
	// Play Button Location
	/** Y2 Location of Play Button */
	private static final int PLAYBUTTON_Y_2 = 381;
	/** Y1 Location of Play Button */
	private static final int PLAYBUTTON_Y_1 = 326;
	/** X2 Location of Play Button */
	private static final int PLAYBUTTON_X_2 = 258;
	/** X1 Location of Play Button */
	private static final int PLAYBUTTON_X_1 = 153;
	
	// ICON Layout Settings
	/** Place to Break First Line of Icons */
	private static final int ICON_LINE_BREAK_2 = 9;
	/** Place to Break Second Line of Icons */
	private static final int ICON_LINE_BREAK_1 = 4;
	/** Starting X Location of Icons */
	public static final double ICON_X = 56.00;
	/** Starting Y Location of Icons */
	public static final double ICON_Y = 220.0;
	/**
	 * Array with character list (NOTE: Any character not there will not be
	 * selectable)
	 */
	public static final String charactersArray[] = { "random", "pharah", "empty", "empty", "empty", "empty", "empty",
		"empty", "empty", "empty", "empty", "empty", "empty", "empty", "empty" };
	
	/** Game Passthrough */
	private SmashGame myGame;
	
	/** Background Layer */
	private BufferedImage background;
	
	/** Static Foreground Layer */
	private BufferedImage staticForeground;
	
	/** Dynamic Character Preview */
	private BufferedImage characterPreview;
	
	/** Character Preview Placeholder */
	private BufferedImage noCharacterPreviewed;
	
	/** Character Preview Placeholder */
	private BufferedImage currentPicker;
	
	/** Boolean State of Main Menu */
	private boolean onMainMenu;
	
	/** Boolean State of Character Menu */
	private boolean onCharacterMenu;
	
	/** Boolean State of Instruction Menu */
	private boolean onInstructionMenu;
	
	/** Directory for Main Menu */
	public static final String MAIN_MENU = "./graphics/menus/main/01.png";
	
	/** Directory for Character Menu */
	public static final String CHARACTER_MENU = "./graphics/menus/character/";
	
	/** Directory for Instruction Menu */
	public static final String INSTRUCTION_MENU = "./graphics/menus/instruction/01.png";
	
	/** String Value of Last Button Clicked */
	private String lastButtonClicked;
	
	/** True When Player 1 Selecting, Else False */
	private boolean isPlayer1;
	
	/** True When Player 2 Selecting, Else False */
	private boolean isPlayer2;
	
	/** Scale Running At */
	private double scale;
	
	/** Timer for Threads */
	private Timer myTimer;
	
	/** True When User Can Click */
	private boolean canClick;
	
	/** Array of Icons that is Generated by Character Screen */
	private ArrayList<CharacterMenuIcon> myIcons;
	
	/** Number of Characters */
	public int numCharacters;
	
	/** Graphics Object */
	private Graphics2D g2;
	
	/**
	 * Constructs New Title Screen
	 * 
	 * @param game Game Passthrough
	 */
	public TitleScreen(SmashGame game)
	{
		super();
		myGame = game;
		this.addMouseListener(new mouseHandler());
		this.addMouseMotionListener(new mouseHover());
		this.setVisible(true);
		this.setFocusable(true);
		this.requestFocusInWindow();
		
		FieldUpdater updater = new FieldUpdater();
		updater.start();
	}
	
	/**
	 * Runs the screen
	 */
	public void run()
	{
		scale = myGame.getScale();
		this.requestFocusInWindow(true);
		mainMenu();
		canClick = true;
	}
	
	/**
	 * Updates the numCharacters variable
	 */
	public void getNumCharacters()
	{
		numCharacters = 0;
		for (String currentCharacter : charactersArray)
		{
			if (!(currentCharacter.equals("random") || currentCharacter.equals("empty")))
			{ numCharacters++; }
		}
	}
	
	/**
	 * Sets Up the Main Menu
	 */
	public void mainMenu()
	{
		lastButtonClicked = "";
		try
		{
			File image = new File(MAIN_MENU);
			background = ImageResizer.resizeImage(ImageIO.read(image), scale);
		}
		catch (IOException ioe)
		{
			System.err.println(ioe);
		}
		onMainMenu = true;
	}
	
	/**
	 * Sets Up The Character Menu
	 */
	public void characterMenu()
	{
		try
		{
			File image = new File(CHARACTER_MENU + "StaticForeground.png");
			staticForeground = ImageResizer.resizeImage(ImageIO.read(image), scale);
		}
		catch (IOException e)
		{
			
		}
		
		try
		{
			File image = new File(CHARACTER_MENU + "noCharacterPreviewed.png");
			noCharacterPreviewed = ImageResizer.resizeImage(ImageIO.read(image), scale);
		}
		catch (IOException e)
		{
			
		}
		
		if (isPlayer1)
		{
			try
			{
				File image = new File(CHARACTER_MENU + "1.png");
				currentPicker = ImageResizer.resizeImage(ImageIO.read(image), scale);
			}
			catch (IOException e)
			{
				
			}
		}
		else
		{
			try
			{
				File image = new File(CHARACTER_MENU + "2.png");
				currentPicker = ImageResizer.resizeImage(ImageIO.read(image), scale);
			}
			catch (IOException e)
			{
				
			}
		}
		
		// Auto Layout Icons From Set Array
		double positionX = ICON_X;
		double positionY = ICON_Y;
		myIcons = new ArrayList<CharacterMenuIcon>();
		
		for (String character : charactersArray)
		{
			myIcons.add(new CharacterMenuIcon(character, scale, positionX, positionY));
			positionX = positionX + CharacterMenuIcon.WIDTH + CharacterMenuIcon.XGAP;
			if (myIcons.size() == ICON_LINE_BREAK_1 || myIcons.size() == ICON_LINE_BREAK_2)
			{
				positionX = ICON_X;
				positionY = positionY + CharacterMenuIcon.HEIGHT + CharacterMenuIcon.YGAP;
			}
		}
		onCharacterMenu = true;
	}
	
	/**
	 * Sets Up Instruction Menu
	 */
	public void instructionMenu()
	{
		lastButtonClicked = "";
		try
		{
			File image = new File(INSTRUCTION_MENU);
			background = ImageResizer.resizeImage(ImageIO.read(image), scale);
		}
		catch (IOException ioe)
		{
			System.err.println(ioe);
		}
		onInstructionMenu = true;
	}
	
	/**
	 * Manages Clicks on Character Menu
	 * 
	 * @param e Mouse Event Passthrough
	 */
	public void characterMenuButtonHandler(MouseEvent e)
	{
		if (canClick)
		{
			for (CharacterMenuIcon currentIcon : myIcons)
			{
				if (currentIcon.contains(e))
				{
					int currentCharacter = 0;
					switch (currentIcon.getMyName())
					{
						case "pharah":
							currentCharacter = 1;
							break;
						case "random":
							currentCharacter = (int) (Math.random() * numCharacters) + 1;
							break;
					}
					if (isPlayer2 && currentCharacter != 0)
					{
						myGame.setPlayer2(currentCharacter);
						isPlayer2 = false;
						this.setVisible(false);
						myGame.screenSwitcher("Game");
						myGame.getMyGameScreen().run();
						onCharacterMenu = false;
					}
					
					if (isPlayer1 && currentCharacter != 0)
					{
						myGame.setPlayer1(currentCharacter);
						isPlayer1 = false;
						isPlayer2 = true;
						canClick = false;
						myTimer = new Timer();
						myTimer.schedule(new ClickDelay(), 2000);
						characterMenu();
					}
				}
			}
		}
	}
	
	/**
	 * Manages Clicks on Main Menu
	 * 
	 * @param e Mouse Event Passthrough
	 */
	public void mainMenuButtonHandler(MouseEvent e)
	{
		int posY = e.getY();
		int posX = e.getX();
		double scale = myGame.getScale();
		if (posX > scale * PLAYBUTTON_X_1 && posX < scale * PLAYBUTTON_X_2)
		{
			if (posY > scale * PLAYBUTTON_Y_1 && posY < scale * PLAYBUTTON_Y_2)
			{
				lastButtonClicked = "Play";
				canClick = false;
				myTimer = new Timer();
				myTimer.schedule(new ClickDelay(), 2 * DEFAULT_MOUSE_DELAY);
				isPlayer1 = true;
				characterMenu();
				onMainMenu = false;
				return;
			}
		}
		if (posX > scale * EXITBUTTON_X_1 && posX < scale * EXITBUTTON_X_2)
		{
			if (posY > scale * EXITBUTTON_Y_1 && posY < scale * EXITBUTTON_Y_2)
			{
				lastButtonClicked = "Exit";
				System.exit(0);
			}
		}
		if (posX > scale * INSTRUCTIONSBUTTON_X_1 && posX < scale * INSTRUCTIONSBUTTON_X_2)
		{
			if (posY > scale * INSTRUCTIONSBUTTON_Y_1 && posY < scale * INSTRUCTIONSBUTTON_Y_2)
			{
				lastButtonClicked = "Instructions";
				canClick = false;
				myTimer = new Timer();
				myTimer.schedule(new ClickDelay(), 500);
				instructionMenu();
				onMainMenu = false;
				return;
			}
		}
		System.out.println(lastButtonClicked);
		lastButtonClicked = "";
	}
	
	/**
	 * Manages Clicks on Instructions Menu
	 * 
	 * @param e Mouse Event Passthrough
	 */
	public void instructionMenuButtonHandler(MouseEvent e)
	{
		if (canClick)
		{
			lastButtonClicked = "Return To Main Menu";
			canClick = false;
			myTimer = new Timer();
			myTimer.schedule(new ClickDelay(), DEFAULT_MOUSE_DELAY);
			mainMenu();
			onInstructionMenu = false;
		}
	}
	
	/**
	 * Paints screen
	 * 
	 * @param g Graphics object
	 */
	public void paintComponent(Graphics g)
	{
		g2 = (Graphics2D) g;
		
		if (onMainMenu || onInstructionMenu)
		{
			g2.clearRect(0, 0, MAX_SCREEN_SIZE_WIDTH, MAX_SCREEN_SIZE_HEIGHT);
			g2.setBackground(Color.BLACK);
			g2.drawImage(background, 0, 0, null);
		}
		
		if (onCharacterMenu)
		{
			g2.clearRect(0, 0, MAX_SCREEN_SIZE_WIDTH, MAX_SCREEN_SIZE_HEIGHT);
			g2.setBackground(Color.WHITE);
			g2.drawImage(characterPreview, (int) (scale * CHARACTER_PREVIEW_X), (int) (scale * CHARACTER_PREVIEW_Y),
				null);
			g2.drawImage(staticForeground, 0, 0, null);
			g2.drawImage(currentPicker, (int) (scale * CURRENT_PICKER_X), (int) (scale * CURRENT_PICKER_Y), null);
			for (CharacterMenuIcon currentIcon : myIcons)
			{ currentIcon.drawMe(g2); }
		}
	}
	
	
	/**
	 * Mouse Handler For Menus
	 */
	private class mouseHandler implements MouseListener
	{
		
		@Override
		public void mouseClicked(MouseEvent e)
		{
			// System.out.println(e);
			
			if (onMainMenu)
			{ mainMenuButtonHandler(e); }
			
			if (onCharacterMenu)
			{ characterMenuButtonHandler(e); }
			
			if (onInstructionMenu)
			{ instructionMenuButtonHandler(e); }
		}
		
		@Override
		public void mouseEntered(MouseEvent e)
		{
			
		}
		
		@Override
		public void mouseExited(MouseEvent e)
		{
			
		}
		
		@Override
		public void mousePressed(MouseEvent e)
		{
			
		}
		
		@Override
		public void mouseReleased(MouseEvent e)
		{
			
		}
	}
	
	
	/**
	 * MouseMotionListener for Menus
	 */
	private class mouseHover implements MouseMotionListener
	{
		
		@Override
		public void mouseMoved(MouseEvent e)
		{
			if (onCharacterMenu)
			{
				characterPreview = noCharacterPreviewed;
				for (CharacterMenuIcon currentIcon : myIcons)
				{
					if (currentIcon.contains(e))
					{ characterPreview = currentIcon.getPreview(); }
				}
			}
		}
		
		@Override
		public void mouseDragged(MouseEvent e)
		{
			
		}
	}
	
	
	/**
	 * Thread to handle repainting screen
	 */
	private class FieldUpdater extends Thread
	{
		
		/** Delay in ms between repainting screen */
		private static final int REFRESH_RATE = 30;
		
		/**
		 * Repaints screen on interval
		 */
		@Override
		public void run()
		{
			while (true)
			{
				repaint();
				
				try
				{
					sleep(REFRESH_RATE);
				}
				catch (InterruptedException ie)
				{
					
				}
			}
		}
	}
	
	
	class ClickDelay extends TimerTask
	{
		
		/**
		 * Allows he user to click again
		 */
		@Override
		public void run()
		{
			canClick = true;
			myTimer.cancel();
		}
	}
}